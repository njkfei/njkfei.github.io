title: 性能优化总结
date: 2016.10.18
categories: 架构 #分类
tags: [java,jvm,性能，架构]
toc: true
---

# 性能优化怎么搞

## 问题提出
* 压力不大,系统居然挂了
* QPS,TPS上不来
* 先重启系统再说

## 原因分析
* CPU是不是满了
* 内存是不是不够用了
* disk是不是频繁的读写
* 网络io是不是爆了

## 怎么办
* 理论
* 工具

## 理论
性能调优是一个系统工程,
需要从整体上去分析系统性能,
理论是最好的武器
### 基本理论点
* 操作系统
* 进程,线程
* 同步,异步
* 计算机网络
* JVM,GC,JMM

### 一些参考数据
* 人人网首页亿级PV,部署10台服务器
* 搜狗搜索,10台服务器
* 1号店:读服务 小于20ms,写服务 小于50ms
* 58同城搜索服务:单台机器9000 QPS
上述数据来源于infoq,或其它公开分享．

## 工具
工欲善其事,必先利其器
或者说,实践是检验真理的惟一标准

### CPU
查看CPU有两条指令.
* top
* uptime
uptime是top命令的子集.只要查看CPU的负载.一般而言,压力测试,首先就要看CPU利用率是否随压力的上升而上升.对于设计良好的系统而言.压力和CPU利用率(load average)是线性关系的.

#### uptime
```
10:01:14 up 161 days, 16:48,  2 users,  load average: 0.01, 0.04, 0.05
```
* load average(负载)需要考虑cpu的核数.
* 负载系数(load average / cpu core count)
* 当负载系数达到 0.7时，需要考虑加机器了
* 当负载系统达到1时，系统达到了最大性能
* 当负载系统达到1.2时，用户的请求开始阻塞了

### 内存
当内存不足时，系统性能会严重下降，但这种不常见．留意一下即可．

#### vmstat
```
niejinping@ubuntu$vmstat 3 100
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 1  0  87244 222132 116088 29564036    0    0     0     1    0    0  0  0 100  0  0
 1  0  87244 222744 116088 29564036    0    0     0    12  232  544  0  0 100  0  0
 0  0  87244 223044 116088 29564068    0    0     0     0  255  639  0  0 100  0  0
```


### 磁盘io
磁盘的性能比内存差1w倍．说个案例
* 某公司某服务大量写日志，把磁盘干爆，不得不重启，然后删除日志
* 某公司接入微信，接入前做压力测试，QPS一直上不去．
你知道后来怎么解决的吗？
查看磁盘的状态可使用dstat命令
#### dstat
```
niejinping@ubuntu$dstat
----total-cpu-usage---- -dsk/total- -net/total- ---paging-- ---system--
usr sys idl wai hiq siq| read  writ| recv  send|  in   out | int   csw 
  0   0 100   0   0   0|1429B   21k|   0     0 |   1B    8B| 271   727 
  0   0 100   0   0   0|   0     0 |1866B 1990B|   0     0 | 253   590 
  0   0 100   0   0   0|   0    28k|1260B  915B|   0     0 | 272   836 
  0   0 100   0   0   0|   0     0 |1784B 1121B|   0     0 | 163   365 
  0   0 100   0   0   0|   0     0 |1652B 1185B|   0     0 | 203   497 
  0   0 100   0   0   0|   0     0 |1943B 1587B|   0     0 | 284   706 
  0   0 100   0   0   0|   0     0 |1102B  458B|   0     0 | 200   489 
  0   0 100   0   0   0|   0     0 |2314B 1259B|   0     0 | 213   515 
  0   0 100   0   0   0|   0    16k|1665B 1363B|   0     0 | 203   496 
```

如果磁盘读写异常，dst/total里面的数据会很夸张的哦，一看就知道了．

#### iostat
```
niejinping@ubuntu$iostat
Linux 3.13.0-86-generic (JHJR-Home-01)  10/18/16        _x86_64_        (32 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           0.11    0.00    0.05    0.01    0.00   99.83

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda               0.66         4.45        20.60   62214026  287806841
```

上面的tps就是iops.kB_wrtn/s如果很大，说明有大量的写操作了．要注意．


##### 性能参考值
类型|IOPS|说明
--|--|--|
普通硬盘|100量级|慢，便宜
SSD|10000量级|非常快，贵

### 网络
说个案例：
* 大量的socket连接，把tomcat挂了．

```
niejinping@ubuntu$lsof -p 17624  
COMMAND   PID    USER   FD   TYPE    DEVICE  SIZE/OFF      NODE NAME
java    17624 product  cwd    DIR       8,2      4096   1971016 /home/product
java    17624 product  rtd    DIR       8,2      4096         2 /
```

wc统计一下，发现socket超过65535了，直接把tomcat挂了．

* 大量复杂对象序列化在网络上传，把网卡搞爆
这个不好搞，要业务重构了．

### 线程

线程可以提高系统的性能，这句话容易产生误导．
合理的使用线程，才能提高程序的性能．在设置线程的参数时．需要考虑以下几个方面：
* 面向IO还是面向CPU
* CPU的核数
* 线上服务还是线下服务
* 锁，锁，锁
#### 面向CPU
* 线程设置为CPU核数即可．

#### 面向IO
* 线程数可以设置大一些

#### 锁
这个就麻烦了，越大，抢锁的概述就越高，这时候线程们可能一直在抢锁，什么也没干．
给我们的启示是：
* 如果线程设置不合理，大家都很忙，大家又好像什么都没干

## JVM
```
内存管理是一个围城，搞C/C++的人想跳进去，搞JAVA的人想跳出来．
```

java程序员不需要在程序代码中管理内存，这是最容易出问题的地方．
```
JVM参数设置不合理，会严重影响程序的性能，这种事情一再发生．
```

* 了解JVM的内存模型，以及分代机制，以利于合理确定JVM参数
* JDK提供了非常多的工具，供程序员使用．

### JVM常用工具
* jstat
* jstatd
* jinfo
* jmap
* jstack
* jconsole
* visualvm
* jmc

#### jstat
这个主要看JVM的GC情况，使用最多．
```
  S0     S1     E      O      P     YGC     YGCT    FGC    FGCT     GCT   
100.00   0.00  41.64   1.00  82.13      4    0.411     2    0.315    0.726
100.00   0.00  41.64   1.00  82.13      4    0.411     2    0.315    0.726
100.00   0.00  41.64   1.00  82.13      4    0.411     2    0.315    0.726
```

#### jstatd
开启远程监控使用的．

#### jinfo
可以看java进程的启动参数

#### jmap
看java进程内的对象

#### jstack
看线程状态．可以分析死锁．
```
"http-9096-exec-1011" daemon prio=10 tid=0x00007f2b34022800 nid=0x7b40 waiting for monitor entry [0x00007f2824e0c000]
   java.lang.Thread.State: BLOCKED (on object monitor)
	at org.apache.log4j.Category.callAppenders(Category.java:204)
	- waiting to lock <0x00007f2c0cf662e0> (a org.apache.log4j.spi.RootLogger)
	at org.apache.log4j.Category.forcedLog(Category.java:391)
	at org.apache.log4j.Category.log(Category.java:856)
```
上面就是大量的线程在抢log4j的文件锁．

#### jconsole
仪表盘式工具，可看cpu,类，gc,线程信息，不如visualvm好用．优点是jdk自带

#### visualvm
非常好用的工具，带丰富的插件．

#### jmc
这个更好用的，但对jdk有版本要求．要求jdk7u40以上的版本．

## 总结
* 理论来指导
* 还要手术刀

### 分析过程
1. 看CPU负载
1. 看GC情况
1. 看硬盘io
1. 看网络io
1. 看线程状态

