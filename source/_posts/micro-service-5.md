title: 微服务系列5-消息驱动数据管理
date: 2016.03.17
categories: 服务 #分类
tags: [架构 ]
---

* 微服务简介
* 构建微服务：使用API网关
* 构造微服务：微服务架构中的进程间通信
* 微服务架构的服务发现
* 面向微服务的消息驱动数据管理
* 微服务部署选型
参考：[Microservices and the Problem of Distributed Data Management](https://www.nginx.com/blog/event-driven-data-management-microservices/)

## 微服务与分布式数据管理难题
单体应用通过使用单一的关系型数据库．使用关系型数据这种方式有一个明显的好处就是可以使用关系型数据库的ACID事务功能．ACID功能提供如下保证：
* Atomic : 数据变更是原子性的
* Consistency : 数据库的状态是一致性的
*　Isolation: 尽管事务操作可以是并发执行的，但从表现来看，事务操作表现的是顺序性
* Durable : 事务操作不可撤销
　这样的就是，你可以放心在一个事务操作中，放心的进行多行的修改操作，然后再提交事务．
　关系型数据库的另外一个优点是提供SQL,它：
* 功能丰富，声明式且标准化的查询语言．
* 用户可以很方便的进行多表联合查询．
* RDBMS系统可以进行性能优化．
* 用户不用考虑数据库系统启动是如何工作的．
总之，关系型数据库很方便．

但是，当我们引入了微服务之后，由于数据属于微服务所私有，因此，应用只能通过API进行访问存取．由于微服务与数据之间相互松散藕合且互相独立，如果多个服务访问同一个数据，性能将会明显下降．

出于多方面的考虑，不同的微服务通过使用不同类型的数据库．现代应用程序存储不同类型的数据到关系型数据库不是最优选择．现在，使用NOSQL数据库已经变得越来越普遍．相对关系型数据库,NOSQL有更好的性能，更好的伸缩性．例如，对于全文检索，你可以通过elasticsearch提供服务．同样的，存储社会图谱数据，Neo4j更适合你．
所以，基于微服务的应用，经常混合使用NOSQL和SQL数据库．这叫做__数据持久多样化__方式．

一分为二地看问题．数据持久多样化还来了很多优势．如解藕，高性能，易伸缩．但是，同样的也引入了分布式数据管理的挑战．

第一个挑战就是如何实现多个服务之间的事务型业务．以B2B在线商城为例．用户服务维护了关于用户的信息，包括信用卡数据．订单服务用于管理订单，在创建订单之前，订单服务需要判断订单金额没有超过信用卡的额度．这个场景在单体应用中，订单服务可以通过ACID事务操作来判断信用卡额度之后再创建订单．

但是，在微服务架构中，订单和客户表是由不同的服务所管理的．如下图所示．

![pics]()

图中，订单服务不能直接访问客户表．只能通过客户服务的API来访问．订单服务可能使用分布式事务，如二阶段提交(2PC).然而，2PC并不是现代应用的可行选项．为解决分布式场景下的ACID问题，引用了__CAP__理论，CAP理论认为，应在ACID之间做出取舍，通过认为可用性是最优选择．但是，在现代技术中，NOSQL数据库并不支持2PC.而数据的一致性又非常重要．因此，在这种情况下，我们需要另一种解决方案．

第二个挑战是如何实现从多个服务之中检查数据．例如，你需要显示用户的最近购买记录．如果订单服务提供了检索订单数据．你可以通过服务端的join来实现．通过join程序，分别向订单服务和用户服务请求数据，再进行聚合．数据的请求，一般是通过主健(如支持主键的NOSQL数据库)．

## 消息驱动的架构
对于大部分应用，__消息驱动的架构__是解决分布式事务的解决方案．在消息驱动的架构中，当有某事件发生时，微服务发布一个事件通知，例如当有更新业务实体数据的情况时．另外一个服务将订阅这些事件．当微服务收到事件哪，它将更新受影响的业务实体数据．这是可能会继续发布更多的事件．

你可以通过__事件__在多个服务之间实现业务的事务操作．一个事务由一系列步骤组成，每个步骤由一个微服务来更新业务实体数据，然后再发布事件来触发通知后续的微服务操作．
下面的序列图展示了如何通过__消息驱动__的方式来检查创建新订单时信用卡和订单之间的联动功能．微服务之间的消息将至通过消息代理中间件来完成．

![pics]()

* 订单服务创建一个订单，通过__NEW__标识，然后发布一个创建订单的消息．

* 客户服务消息订单创建事件，然后检查信息卡数据，并将信用卡账户信息发布出去．
* 订单服务消费信用卡数据事件，然后检查信用卡额度和订单金额，根据它们之间的关系来决定是否开放订单．
* 后续有更复杂的场景，如当用户信用卡额度检查通过后，需要扣减商品库存．

假设每个服务将自动更新数据库然后再发布事件．并且，消息代理中间件会保证事件至少发布一次．你可以轻松实现跨业务的事务性．
但是，这些都不是ACID事务．在分布式场景中，一般提供弱保证如"最终一致性"．这种事务模型被称为__BASE模型__．
　你可以通过事件来实现视图．将多个微服务的数据进行聚合．这个聚合服务将订阅相关的事件，然后更新视力．如下图所示．
![pics]()
用户订单视图订阅用户服务和订单服务的事件．．
当收到用户服务或订单服务的事件时，用户订单视图服务更新数据库．你可以使用文档型数据库，如mongodb．

## 实现原子性
 在消息驱动架构中．如果保证更新数据库的同时并成功发布消息是一个难题．例如，如订单服务向数据库中插入一条记录时，应同时发布订单创建事件．这应该是同时完成的，但是，如果事件发布失败，那么，数据将变得不一致．标准的解决方法是通过分布式事务来保证数据库和消息中间件这两个操作的原子性．出于CAP原理的约束，这是我们不愿意看到的．
 那么，如何实现原子性呢？

### 通过本地事务发布事件
　一种方法就是通过事务本地化，即将订单表和流水表放在同一个数据库中．其中，流水表充当消息队列的作用．即实体数据和状态数据在同一个数据库中．另通过进程或线程的方法．来侦听流水表，当有事件未发布时,则将事件发布给消息中间件，当消息被正常消费后,再更新流水表的状态．如下图所示．
![pics]()

图中：
* 订单服务插入一条订单记录到订单表,然后再插入一条订单创建消息到消息表.
* 另外一个独立的进程或线程(发布线程)查询事件表,获取未发布事件,发送给消息中间件
* 当事件被正常消费后,发布线程更新事件表,标志事件已完成发布.

#### 优点
* 不依赖于2PC完成事件正确发布

#### 缺点
* 易于出错，需要程序员保证发布事件
* 当通过NOSQL实现时，会有难度，因为NOSQL不支付事务，或者支持的力度有限．

### 挖掘数据库事件日志
　另外一个实现2PC的方法是通过挖掘数据库的事务或提交日志．这可以通过一个后台进程或线程来实现消息发布功能．即事务日志挖掘器进程或线程读取事务日志，然后发布消息给消息中间件，如下图所示．
![pics]()

典型用例：
* LinkedIn Databus
* AWS DynamoDB

### 使用事件源
 暂空．

## 总结
### 优点
* 解决了跨服务的事件，并提供最终一致性
* 提供物化视图的方法，解决数据聚合的问题

### 缺点
* 相对单数据库的ACID事务，消息驱动的架构太复杂了
* 当应用故障是，需要实现事务补偿功能
* 需要解决事件丢失和事件重复的CASE

　在微服务架构中，每个微服务有自己私有的数据库．出于性能等方面的的设计考虑，每个微服务的数据库可能选择SQL或NOSQL．这带来了分布式数据管理的挑战．如
* 如何实现跨服务间业务事务的一致性．
* 如何从不同服务之间获取数据．

对于大部分应用而言，解决方案是：使用消息驱动的架构．
实现消息驱动架构的难点在于：如何自动更新数据，如何发布消息．
这里有多种解决方案,包括：
* 使用数据库作为消息队列中间件
* 通过挖掘事务日志
* 事件源传播