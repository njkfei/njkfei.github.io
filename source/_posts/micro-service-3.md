title: 微服务系列3-进程间通信
date: 2016.03.12
categories: 服务 #分类
tags: [架构 ]
---

* 微服务简介
* 构建微服务：使用API网关
* 构造微服务：微服务架构中的进程间通信
* 微服务架构的服务发现
* 面向微服务的事件驱动数据管理
* 微服务部署选型

## 引言
  在单体应用中，组件之间调用另外一个组件的功能是通过语言级别的方法或函数调用完成．然后，基于微服务的应用，分布式系统运行在不同的机器之上．每个服务实例一般是一个进程．因此，服务之间通过进程间通信IPC的机器进行通信．
  如下图所示．
  ![pics]()

  后面我们将讨论进行间通信技术，在此之前，我们先看一个设计方面的议题．

 ## 交互风格
 当我们在服务之间选择进程间通信机制相互访问时，先看看服务之间是如何交互的．
 在服务之间客户端与服务器有多种风格的交互方式．它们可以被规纳为2个维度．
 第一个维度通过交互是1对1还是1对多进行划分.
 * 1对1 每个客户端的请求被一个服务实例所处理
 * 1对多 每个请求被多个服务实例所处理.
 第二个维度是根据是否是同步还是异步来划分.
 * 同步 - 客户端期待在确定的时间内获得来自服务端的响应.在等待的过程中,客户端将会阻塞住.
 * 异步 -客户端不会阻塞等待服务端的响应.

 如下所示.

| Tables        | 一对一           |  一对多  |
| ------------- |:-------------:| -----:|
| 同步      | 请求/响应 | - |
| 异步      | 通知 请求/异步响应      |   发布/订阅 发布/异步响应 |

### 一对一交互
一对一交互有下面３种风格：
* 请求/响应: 客户端发送请求，等待响应．客户端在期望的时间窗口内阻塞等待响应．在基于线程的应用中，线程将产生请求，并阻塞等待响应．
* 通知（一次请求）：客户端发送请求给服务．但不服务方进行响应．
* 请求/异步响应:客户端发送请求给服务，但是响应是异步的．此时客户端不会进行阻塞．

### 一对多交互
一对多交互有如下类型：
* 发布/订阅：客户端发布一个通知消息．这个通知消息可以被０或者多个订阅服务所消费．
* 发布/异步响应：客户端发布一个请求消息，然后在一定时间范围内等待多个服务在响应．
　通知每个服务会使用上述交互风格中的一个或多个．对于一些服务,一个IPC机制就足够了．但是另一引动服务可能需要使用多种IPC机制．下图展示了打车应用中乘客请求打车中的交互．

![pics]()

上述服务包含了通知，请求/响应，发布/订阅等交互方式．例如，乘客通过手机发送一个__通知__给旅行管理服务请求打车，旅行管理服务将通过__请求/响应__的方式调用乘客管理服务验证乘客的身份，然后旅行管理服务创建__行程单__，再通过__发布/订阅__的方式发送给调度服务，调度服务再选择中可用的司机给乘客．

看完了交互风格，咱们再看一下如何定义API.


## API定义
服务API是连接服务和客户端之间的纽带．不管你采用何种IPC机制．你必须通过某种接口定义语言IDL精确的定义服务的API.
服务定义，API先行．你首先开始定义服务接口，然后与客户端工程师进行评审．服务定义完成后，再开始进行服务实现的迭代开发．
提供进行API设计，将加速构建服务的过程，并且容易满足客户端的需求．
在后文将提到，API的定义，依赖于你所采用的IPC机制．
* 如果采用消息机制，那么API应包括消息通道和消息类型．
* 如果采用HTTP协议，那么API应包括URL和请求与响应的参数．

## API演化
随着时间的推移，API将不可避免的变化，在单体应用中，当API变化时，一般可以通过修改更新函数调用处代码完成．但是，微服务应用相对比较困难．你不能强制所有客户端进行升级来适应你的服务．因此，你应该增加部署新版本的服务使得新版本服务可以同步运行．这里很重点一点就是你必须要有一个策略来处理此类问题．
如此处理API的变化问题，如果一些变化很小，那么应向后兼容以前的版本．例如，增加请求的属性参数或响应参数．
你应该坚持客户端与服务端之间保持__鲁棒原则__．如果客户端使用老的API也能在新服务下正常工作．服务端提供默认值给缺失参数的客户请求．并且客户端忽略响应中的多余数据．

然而，有时候，你必须做为重点且不兼容的API变化，因为你不能强制客户端立即升级．服务端必须在一段时间内支持老的版本．如果你采用基于HTTP机制如REST请求，一个方法不是在请求URL中加上版本号．每个服务实例可以同时处理多个版本．另外一种可选的方案是，你可以部署不同的实体来处理不同的版本．

## 处理局部失效
由于客户端和服务端是独立且隔离的进程，出于服务宕机或者服务升级的原因，．服务可能没有各客户端请求回复响应．或者由于负载加大，导致服务响应时间延长．
比如说，在产品详情页的场景中，我们想象一下，如果推荐服务不可用，一个原生的客户端可能阻塞等待响应．

处理局部失败的方法：
* 网络超时：等待响应时，不进行阻塞，而是通过超时机制保持资源不被占用．
* 限制外部请求的数量：对于特定的服务，限制外部请求的数量．当超过请求上限时，服务立即向客户端回复不可用．
* 断路器模式：通过根踪统计请求的正确和错误响应的数据，如果错误数超过了配置的上限，那么断路器，使得后续的请求立即失效．如果大量的请求失效．就建议使服务不可用，这样发送给请求将变得无效．当客户端请求成功后，再重新关闭断路器．
* 采用回退机制：当请求失败时，提供回退的逻辑．例如，返回缓存的数据．或者提供默认值．比如，返回一个固定的推荐信息(热门商品也行啊)．

## IPC技术
　对于IPC,这里有很多不同的IPC技术可以供选择．选择列表如下：
* 同步通信．如Thrift或REST
* 异步通信：基于消息机制的AMQP或STOMP.
对于通信的内容，也有不同的格式．从易于理解的可读性的JSON或XML,到使用二进制协议(通常意味着高效)如Protocal Buffer或Avro．

### 基于消息的异步通信
当使用异步消息时进行异步信息交换时，客户端通过消息将请求发送给服务，如果服务准备好了回复，将发送一条另外的消息给客户端．因为通信是异步的，客户端不需要阻塞等待响应．
消息由消息头(如发送方的元数据)和消息体组成．消息通过__通道__进行传输．消息生产者可以发送消息给通道．消息消费者可以从通道中接收消息．
这里有两种类型的通道：
* 点对点
* 发布－订阅
点对点通道传输的消息，仅可以被一个消费者从通道中读取．使用点对点通道的服务是前面所述的一对一交互模式．
发布－订阅通道可以将消息发送给所以关注消费者的服务．使用发布订阅通道的服务是前面所述的一对多交互模式．
下面的图示展示了打车应用　中使用的发布订阅通道．
![pics]()

当一个行程单创建时，旅行服务发布一个行程消息到通道中．调度服务订阅从通道中获取消息，然后找出合适的司机，然后将派单信息发送到通道之中．这时候，订阅了派单信息的消息推送服务中通道中取出消息，再发送给司机和乘客．

#### 消息选型：
消息系统有很多种，你最好选择支持多种语言的消息系统．
一些消息系统支持标准协议，如AMQP或STOMP.
一些消息系统是私有协议，但已经文档化，有很多开源消息系统如RabbitMQ,Apache Kafka,Apache ActiveMQ和NSQ.
在高级别上，这些消息系统支持各种消息和通道．它们都朝着可靠，高性能，可伸缩方向发展．

#### 使用消息的优点 
* 客户端与服务端解藕　：　客户端发送消息给相应的通道即可，不需要关心服务实例的位置．不需要使用发现机制确定服务实例的位置．
* 消息缓冲　：在请求/响应式协议(如HTTP)中，客户端和服务端在交换信息期间必须同时在线．相反，消息代码缓冲消息，直到消息被消费者所处理．举个例子，在线商城应用中，当订单被创建时，如果订单处理系统不可用，订单信息可以缓存起来，当订单处理系统恢复后，可以继续完成处理．
* 客户端－服务端柔性交互：

#### 消息系统的缺点
* 额外的运维复杂性　：　消息系统是一种系统组件，它需要被安装，配置和运维．而且应保证消息系统的高可用性．否则如果消息系统是单点的话，则存在单点故障，系统的可靠性会产生影响．
* 相对请求响应方式复杂些．不展开描述

### 请求/响应式同步IPC
当使用请求/响应式同步IPC机制时，客户端发送请求给服务端，服务端处理请求，然后发送响应给客户端．通常大部分客户端，是由线程阻塞来等待响应．也有些客户端通过事件驱动的异步机制来等待响应．这可能是通过__Futures__或__Rx__观察者来封装实现．这里有很多协议可以选择，两种流行的协议是REST和Thrift.
#### REST

没必要展开了，很多地方地介绍．

#### Thrift
支持多种语言，自动生成代码．over

### 消息编码
#### JSON
#### XML
#### Protocal Buffer
推荐JSON,如果对性能要求高，则推荐PB.


## 总结
 当你采用微服务时，进程间通信不可避免．在设计进程间通信时，需要考虑下面几点：
* 服务间如何交互？
* 如何设计API？
* 如何应用API演化？
* 如何处理失效？

这里有两种进程间通信机制，同步请求响应和异步消息机制．在后面的文章中，我们将看看服务发现的问题．