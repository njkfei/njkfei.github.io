title: 微服务系列1－微服务简介
date: 2016.03.10
categories: 服务 #分类
tags: [架构 ]
---

* 构建微服务：使用API网关
* 构造微服务：微服务架构中的进程间通信
* 微服务架构的服务发现
* 面向微服务的事件驱动数据管理
* 微服务部署选型
* 
## 引言
　当前，微服务吸引了越来越多的目光,无论是文章，博客，社交媒体，还是学术会议.在各种热词排行榜中，都能看到微服务．


## 构建单一整体应用
	假设我们正在开始构建一个类似于UBER的全新的打车应用．在经过前期的预备会议和需求收集后，我们构建好了一个全新的应用．这种应用可以通过spring boot 或者　rails 或者play框架．这个应用的架构如下所示的六方法所示．

	![pics](imgs/arch/service/mircroservice/pic1.jpg)

图中，在应用的核心位置是业务逻辑．业务逻辑是通过一系列模块组成．这些模块定义了服务，领域对象和事件．围绕着核心功能，是与外部世界的适配器和接口．例如数据库访问组件适配器，用于生产和消费消息的组件．以及暴露API的web组件或UI组件．

	除了拥有一个模块架构外，整个应用是做为一个单体应用进行打包和部署的．实际情况依赖于应用所采用的语言和框架．例如：
* JAVA应用将打成一个WAR包．这些WAR包将部署在Tomcat或Jetty等WEB容器上．
* 内置WEB容器的java包
* 独立目录部署的应用．例如Rails或Node.js应用

	这种设计方式的单体应用非常普遍，它们非常容易开发，因为我们的IDE或者其它工作都聚焦于构建这种单体应用．这些应用同时也很容易测试和．你可以通过_Selenium_对UI进行端到端的测试．单体应用同时也晚易于部署．你可以复制部署包到其它服务器．你同样可以通过多份复制的方式，通过负载均衡器，进行水平伸缩．
	在早期阶段，单体应用运行还是非常好的．

##　走向单体应用恶梦
　不幸的是．简单的方法有一个巨大的限制，随着时间的推移，成功的应用一般增长迅速，并且变得越来越大．通过每次前进，你的开发团队实现了越来越多的功能，当然，这也意味着增加了越来越多的代码．
	几年之后，你的细小，简单的应用变成了巨大的单体怪物．举个极端的例子，我最近遇到了一个工程师，他写了一个工具，用于分析几千个JAR包．这些jar包由数百万行代码组成．我确定他这些年作出了巨大的努力．

	一旦你的应用变大，变得复杂．你的开发团队将陷入痛苦的境地．任何尝试敏捷开发将会是一场无用的折腾．问题主要原因是单体应用变得难以逾越的复杂．对于任何开发人员而言，单体应用因为巨大的复杂性，而无法完全理解．这样的结果是，定位BUG或者正确实现新的功能将变得困难而费时．更严重的是，这将进入一个死循环，如果代码变得难于理解，后续的任何变更将无法保持正确．你将面对一个无法理解的大怪物．

	大型单体应用将减慢开发速度，单体应用越大，启动时间越长，例如，最近调查显示一些开发者报告这个应用的启动时间达到了12分钟，我曾经听说启动时间花了40分钟．如果工程师不得不重启应用服务器，那么一天的大部分时间是等等产品启动．

	另外一个大问题是，复杂的单体应用，将阻碍持续开发．今天，SAAS应用推动了生产方式的变化．对于复杂的单体应用，修改其中的一部分，然后对其进行重新部署将变得极其困难．而不仅仅是前面提到的启动时间过长．此外，因为变更的影响通常无法易于理解，因此，你需要进行大量的人工测试，来确认变更的正确性．最后的结果是，持续开发将变得几乎不可能．

	单体应用还难以协调不同模块之间的资源冲突问题．例如，一个模块是CPU密集的图像处理逻辑，它最理想的部署是EC2优化计算实例．另外一个模块是一个内存数据库，它最适合部署在EC2内存优化实例上．然后，由于这些模块部署在一起，你不得不综合权衡硬件选型．

	还没有完，另外一个单体应用的问题是可靠性．由于所以模块运行在同样的处理器上，如果任何一个模块有BUG,例如内存泄漏，可能影响整个处理器的性能．进一步地，因为所有实例是相同的，因此，这个BUG将影响所有的机器．

	还有，单体应用使得采用新的框架或新的语言变得困难．例如，让我们想象一下，你有一个2百万行代码它们使用XYZ框架编写．如果你想改用最新的ABC框架重写，这种代价极其昂贵，即使新的框架是被认为是更优的．结果就是，采用新技术将遇到巨大的阻力，你将被采用任何新技术选择所卡住．

	总结来看：你将拥有一个成功的关键业务的应用，它会变成巨大的怪物．开发者们知道，它将继续使用落后，淘汰的技术．这使得招聘优秀的工程师变得困难．这种应用将变得难于伸缩又不可靠．最后就是，敏捷开发和发布将变得不可能．

	那么，你将怎么办呢？

## 微服务：搞定复杂性问题
　很多组织，例如Amazon,eBay和Netflix，已经采用现在称为__微服务架构模式__的方法来解决问题．而不是构建一个巨大的单个怪物－单体应用．这个方法是分解你的应用为一系列更小，内部互相连接的服务．

	典型的，服务是一组明显的特征，或者功能的集合．例如订单管理，客户管理等．每个微服务是一个微小的应用．它们也有自己的__六边形架构__，有通过各种适配器组成的业务逻辑．一些微服务通过暴雷API来供其它微服务消费．其它微服务可能实现一Web UI.在运行时，每个实体可能是一个云上的虚拟机，或者是一个DOCKER容器．

	例如，解藕后的系统将由下图所示的微服务组成．

	![pics](imgs/arch/service/mircroservice/pic2.jpg)


	现在，上图中的每个功能区是由自己的微服务实现．例如WEB应用被分解为简单WEB应用的集合(例如打车应用中的乘客和司机)．这种方法对于用户，设备或特定的用例都非常容易．

	每个后端服务通过REST API来暴雷服务．并且大部分服务通过API来消费其它服务．然后，这些服务没有通过地址访问的方式来访问后端服务．反而代之的是，服务间内部通信是通过__API网关__来实现．__API网关__是用来处理负载均衡，缓存，访问控制，API测量和监控．这可能通过__NGINX__实现．后面的文章将讨论__API网关__.

	我们来看一看下面这张立方体图．

	![pics](imgs/arch/service/mircroservice/pic3.jpg)

	在这个立方体中，Y轴方向表示将应用进行切分解藉．X轴方向表示通过复制的方式进行水平扩展．Z轴表示对数据进行切分，例如通过主键进行分库分表．

## 服务化的优点
　　微服务有很多优点．
* 首先，它用来处理复杂的问题．它可以将复杂的单体应用解藉成一系列服务．并保持整体功能不变．这个应用被分解为可管理的服务．每个服务都有一个良好定义的边界．通过RPC或者消息驱动的API提供服务．微服务架构提供了模块性等级．在实践中通过单体应用它很难达到这种模块性级别．结果就是，单独的微服务可以更快开发，更易理解和维护．
* 其次，微服务架构模式允许每个服务进行单独的部署，工程师不需要考虑外部的变更部署．这些变更易于测试．例如，UI团队可以执行AB测试和快速迭代．微服务架构模式提供了技术部署的可能性．
* 第三，微服务架构模式允许每个微服务进行独立的开发．开发团队可以聚焦在特定的服务之上．工程师可以自由的选择他所擅长的技术．当然，大部分组织希望避免过多的技术选项．然后，这种自由度意味着工程师在新项目中可避免使用过时的技术．当启动一个新服务时，他们有选择流行技术的可能性．另外，这些服务相对较小，使得可以容易地通过最新技术进行重写．
* 最后，微服务架构允许独立的进行伸缩，你可以通过调整实例的数量进行扩容．另外，你可以选择最适合的硬件来匹配微服务．例如，可以给CPU敏感的服务部署在EC2 cpu优化实例上．可以将内存数据库部署在EC2内存优化实体上．

## 服务化的缺点
在30年前的"人月神话"就已经提出．世人没有__银弹__．和其它技术一样，微服务架构也是有缺点的．
* 首先：

* 其次,微服务意味着分布式,分布式将带来新的问题.

* 还有,测试微服务是比较复杂的.例如,通过现代框架例如spring boot,编写一个针对通过REST API单体web应用的测试用例是比较简单的.但测试微服务相对比较复杂.

* 还有,微服务之间存在依赖性, 这样将给部署带来问题.例如A,B,C服务中,B依赖于C,那么,需要C服务先启动.
* 部署微服务也存在困难.

## 总结
 构建复杂应用本身就有内在的困难,一个单体架构适合在理解上简单,轻量的应用上.将你采用复杂的单体应用时,你将走向痛苦的境地.微服务架构模式是解决复杂的一个更优选择.
 